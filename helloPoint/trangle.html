<!--
 * @Descripttion: 
 * @Author: 笙痞
 * @Date: 2023-02-27 22:40:12
 * @LastEditors: 笙痞77
 * @LastEditTime: 2023-03-03 10:30:15
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body onload="main()">
  <canvas id="webgl-container" width="400" height="400"></canvas>
  <script src="../../utils/webgl-utils.js"></script>
  <script src="../../utils/webgl-debug.js"></script>
  <script src="../../utils/cuon-utils.js"></script>
  <script src="./helloPoint2.js"></script>
  <script id="vertex-shader-2d" type="notjs">
      // 属性变量，会从缓冲区获取数据
      attribute vec4 a_position;
      // 所有着色器都有一个main方法
      void main() {
        // 顶点着色器的变量
        gl_Position = a_position;
      }
    </script>
  <script id="fragment-shader-2d" type="notjs">
      // 片段着色器需要设置精度
      // mediump是一个不错的默认值，代表“medium precision”（中等精度）
      precision mediump float;
      void main() {
        // gl_FragColor是一个片段着色器主要设置的变量
        gl_FragColor = vec4(1, 0, 0.5, 1) // 返回“瑞迪施紫色”
      }
    </script>
  <script>
    const canvas = document.querySelector("#webgl-container")
    const gl = canvas.getContext("webgl")
    /**
     * @description: 创建着色器
     * @param {*} gl
     * @param {*} type 着色器类型
     * @param {*} sourc 数据源
     * @return {*}
     */
    const createShader = (gl, type, sourc) => {
      // 创建着色器对象
      const shader = gl.createShader(type)
      // 提供数据源
      gl.shaderSource(shader, source)
      // 编译生成着色器
      gl.compileShader(shader)
      const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (success) {
        return shader;
      }
      console.log(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader)
    }
    const vertexShaderSource = document.querySelector("#vertex-shader-2d").text;
    const fragmentShaderSource = document.querySelector("#fragment-shader-2d").text;
    // 创建着色器
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource)
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    // 将着色器连接到一个着色程序上
    const createProgram = (gl, vertexShader, fragmentShader) => {
      // 着色程序
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader)
      gl.attachShader(program, fragmentShader)
      gl.linkProgram(program)
      const success = gl.getProgramParameter(program, gl.LINK_STATUS)
      if (success) {
        return program
      }
      console.log(gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
    }
    const program = createProgram(gl, vertexShader, fragmentShader)
    // 从的GLSL着色程序中找到a_position所在的位置
    const posAttributeLocation = gl.getArrribLocation(program, "a_position")
    // 创建缓冲区
    const posBuffer = gl.createBuffer();
    // 绑定数据源到绑定点
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer)
    // 三个二维点坐标
    const positions = [
      0, 0,
      0, 0.5,
      0.7, 0,
    ];
    // 通过绑定点向缓冲区中存放数据
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  </script>
</body>

</html>